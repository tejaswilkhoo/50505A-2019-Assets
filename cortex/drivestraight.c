#pragma config(Sensor, dgtl7,  leftdriveencoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rightdriveencoder, sensorQuadEncoder)
#pragma config(Motor,  port1,           leftdrive1,    tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           leftdrive2,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightdrive2,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          rightdrive1,   tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void driveStraightDistance(int distance, int masterPower, int type)
{
  int tickgoal = distance;
	int totalticks = 0;

  int slavePower;
  int error = 0;
  int kp = 5;

  SensorValue[leftdriveencoder] = 0;
  SensorValue[rightdriveencoder] = 0;

  if (masterPower < 0)
  {
  	slavePower = masterPower + 16;

	  while(abs(totalticks) < tickgoal)
	  {
	    motor[leftdrive1] = masterPower;
	    motor[leftdrive2] = masterPower;
	    motor[rightdrive1] = slavePower;
	    motor[rightdrive2] = slavePower;

	    error = SensorValue[leftdriveencoder] - SensorValue[rightdriveencoder];

	    slavePower += error / kp;

	    SensorValue[leftdriveencoder] = 0;
	    SensorValue[rightdriveencoder] = 0;

	    wait1Msec(100);

	    totalticks+= SensorValue[leftdriveencoder];
	  }
  }

  else
  {
  	slavePower = masterPower - 6;
	  while(abs(totalticks) < tickgoal)
	  {
	    motor[leftdrive1] = masterPower;
	    motor[leftdrive2] = masterPower;
	    motor[rightdrive1] = slavePower;
	    motor[rightdrive2] = slavePower;

	    error = SensorValue[leftdriveencoder] - SensorValue[rightdriveencoder];

	    slavePower += error / kp;

	    SensorValue[leftdriveencoder] = 0;
	    SensorValue[rightdriveencoder] = 0;

	    wait1Msec(100);

	    totalticks+= SensorValue[leftdriveencoder];
	  }
  }

  SensorValue[leftdriveencoder] = 0;
  SensorValue[rightdriveencoder] = 0;

  if (type == 1)
  {
		if (masterPower > 0)
		{
	    motor[leftdrive1] = -10;
	    motor[leftdrive2] = -10;
	    motor[rightdrive1] = -10;
	    motor[rightdrive2] = -10;
		}

		else
		{
	    motor[leftdrive1] = 10;
	    motor[leftdrive2] = 10;
	    motor[rightdrive1] = 10;
	    motor[rightdrive2] = 10;
		}
  }

	if (type == 0)
	{
		motor[leftdrive1] = 0;
		motor[leftdrive2] = 0;
		motor[rightdrive2] = 0;
		motor[rightdrive1] = 0;
	}

}

task main()
{
  SensorValue[leftdriveencoder] = 0;
  SensorValue[rightdriveencoder] = 0;
  driveStraightDistance(4000,127,0);
  wait1Msec(500);
}
